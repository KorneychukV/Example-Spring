Иструкция описывает, как создавать проект с помощью IntelliL IDEA, а также как написать приложние для CRUD операций.
0. Приложение можно создать клонировав из репозитория к себе GetStarted проект git clone https://github.com/spring-guides/gs-spring-boot.git.
0.1 Там есть папка Initial в ней лежит проект с одним endpoint'ом. Можно взять его за основу, но в IDE создавать проект удобнее.

1. В IDE открываем File -> New -> Project.
2. Выбираем Spring Initializr
2.1 Заполняем все необходимыые поля (тут всё как всегда) и нажимаем Next
3. Выбираем необходимую версию SpringBoot, а затем зависимости, которые будем использовать в нашем проекте.
3.1 Стоит выбрать: Spring Web (для упращения разработки в RESTful приложений), Spring Data JPA (для удобства работы с БД), нужный драйвер БД (например PostgreSQL Driver).
3.2 Нажимаем Next и завершаем создание.

Далее пропишем дальше зависимиости в pom.xml
1. Добавляем hibernate-core, для работы с hibernate
2. 

Смотрим основной класс, который у нас создался (src -> main -> java -> ... Да он там один). У него проставлена аннотация @SpringBootApplication, которая конфигурирует приложение, при этом сканирует пакеты приложения для поиска компонентов с дополнительными конфиграциями (Лучше почитать отдельно если интересно).
Скажем так, этот класс конфигурирует и запускает наше приложение. Его можно не трогать.

Сконфигурируем наше приложение.
1. Открываем файл конфигурации, старый-добрый application.properties, находится в папке resources.
2. Всё похоже на Quarkus, в примере у меня добавлены настройки можно их посмотреть, там всё понятно.
3. (Дополнительно) В resources автоматом добавились папки static и templates можно спокойной их удалять, не на данный момент они нам не понадобятся.

Создадим сущность в БД над которой будет проводить CRUD-операции. Здесь всё как раньше, т. к. работаем с hibernate.

Создадим контроллер, для выполнения CRUD-операций над сущностью. 
1. Проверил некоторые аннотации, описываю:
1.1 @CrossOrigin(origins = "http://localhost:8081") - прописываем адреса с которых можно делать кросс-доменные запросы. Предполагаю, что можно это прописать и в application.properties.
1.2 @RestController - обязательно проставлять. Обозначет, что данный класс является REST-контроллером
1.3 @RequestMapping("/api") - указываем адресс нашей конечной точки.
2. Помимо этого стоит использовать следующие аннотации внутри класса, такие как:
2.1 @Autowired - это наш любимы Dependency injection
2.2 @GetMapping("/test") - можно вешать на методы, для обозначения пути для их вызова.
2.3 Если мы в пути передаём переменную, то в аргументах к методу требуется указать в какую переменную в программе мы будем записывать значение. Для этого используется следующий код "@PathVariable("name_path_var") long name_app_var", где: name_path_var - наименование передаваемой переменной, name_app_var - наименование принимаемой переменной.
2.4 Чтобы сериализовать тело запроса необходимо использовать следующий код "@RequestBody SerialClass serialVar", где:
SerialClass - класс описывающий структуру для сериализации данных, serialVar - переменная, в которую будут записаны сериализованные данные

Для удобной работы с БД, в Spring используется JpaRepository. Это интерфейс предоставляющий набор стандартных методов JPA для работы с БД. Помимо этого его можно доплонять своим функционалом, об этом далее.
1. Создадим репозиторий для работы с нашей тестовой сущностью TestRepository. Это интерфейс, который должен наследоваться от JpaRepository, которому в свою очередь нужно указать 2 дженерика, а именно: класс-сущность, с которым будем работать и тип идентификатор сущности.
2. По идее на этом можно и закончить, далее опишу как с этим можно работать.
3. (Дополнительно) Здесь есть много разных приколюх, рассмотри парочку:
3.1. Можно добавить свой метод, который будет выполнять поиск по необходимому нам полю, например, объявляем: List<TestTable> findByPublished(boolean published); Этот метод будет выгружать из БД значения с фильтром по полю Published. Здесь не нужно дописывать свою реализаю, требует назвать метод следующим образом "findByName", где Name это наименования поля сущности.
3.2. Кроме просто поиска по полю можно добавить ключевые слова к названю класса для дополнительных фильтраций, например, findByTitleContaining. Там много всего есть, лучше почитать https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#appendix.query.method.subject
3.3. Помимо этого можно даже на метод повесить аннотацию @Query и написать свой запрос, который будет выполняться при вызове данного метода.
3.4. Штука удобная для выполнения простых CRUD-операций, но всё равно стоит использовать и отдельные сервисы для обработки данных.

Создадим сервис для обработки данный.
1. Сервис можно создать как просто классом в реализацией, так и сделать для него отдельный интерфейс и имплементить его. САМОЕ ГЛАВНОЕ, чтобы на классе-сервисе висела аннотацию @Service, тогда его можно будет заинжектить.
2. У меня в примере приведено два подхода работы с сущностями, а именно: через JpaRepositoryи и через Hibernate (как раньше). Оба работают и имеют право на существование.

Далее создадим необходимые endpoint'ы и реализуем необходимый функционал.

Запуска приложения.
0. Сначала запустим БД.
1. Далее запустим приложение
1.1 либо с помощью IDE (там уже всё сконфигурировано)
1.2 либо из корня приложения командой ./mvnw spring-boot:run